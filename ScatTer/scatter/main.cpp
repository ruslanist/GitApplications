// ОТВЕТЫ НА ТЕСТ
/*
1)
Шабонная функция принемает два шаблонных типов T и F. В этом примере шаблонные типы могут быть разными.
Смгнатура шаблоной функции find_best принемает два параметра: задают вектор и указывают параметр T и параметр указатель  F на функцию.
В теле функции ind_best вызывается функция sort(), которая осуществляет сортировку вектора потипу заданому в лямда фунуции.
Возрашает аблоной функции find_best количество элементов содержащихся в векторе после сортировки

Шаблонная функция рабртает следующим образом:
В функцию при вызове первым параметром прокидывается вектор шаблонного типа, а вторым параметром указатель на функцию шаблоного типа
В теле функции происходит вызов функции sort(), которая производит сортировку данных вектора шаблоного типа.

Логика сортировки может быт следующая:
В полученный вектор содержит к примеру Json файлы в которых содержится информация (Организация, дата, максемальное число роста, и.т.д)
Функция sort() 1-м и 2-м параметром определяет длину, кол-во Json файлоыв в векторе.
Далее 3-й параметр sort() задает логику сортировки элементов этого вектора, а именно используя ункцию лямбда, в ее теле происходит вызов функци score_fun(),
которая отсортирует полученный Json(получаем число максемального роста валюты за день) определенного индекса.
После выполнения score_fun(lh) < score_fun(rh) возвращается число которое будет далее сортироватся от меньщего к большему
Выражение  return collection[collection.size() - 1], возвращает значение последнего элемента вектора к пр имеруу collection[99].
В итоге функция find_best возвратит после сортировки, последнее число в векторе которое будет максемальным числом роста валюты к примеру за квартал и.т.д.
Так же можно после сортировки обойти масив в цикле for<, и вывести все его элементы, и получить информацию об статусе увеличение валюты за в конкретном пириоде

2) O(N·log(N)), где N = std::distance(first(ollection.begin()), last(collection.end())) применения cmp.
Иметь сложную временную сложность среднего порядка (n log n). Любой алгоритм может использоваться при условии, что это требование временной сложности выполнено

3) В строках 26 и 27, в момент работы score_fun, В ЗАВИСИМОСТИ ЗАЛОЖЕННОЙ ЛОГИКИ В ЕЕ ТЕЛЕ

4) Проблема может возникнуть в момент возвращения из функции  collection[collection.size() - 1].
Это связанно с тем что, если полученный вектор окажется пустым, то выражение - 1 будет вычтено у пустого вектора, collection[0] -1,  таким образом функция возратит чужую область памяти к примеру с мусором

5) сделать проверку за счет средства ветвления, логического оператора if(collection.empty())
 выше вызова функции sort()
Далее в  теле if можно будет выкинут эксепшен

template <class T, class F>
auto find_best(std::vector<T> collection, F score_fun) {
    if(collection.empty()) {

     cout << "Вектор Пуст" << endl;
    } else {

            std::sort(
                collection.begin(),
                collection.end(),
                [score_fun](auto lh, auto rh){

                    return score_fun(lh) < score_fun(rh);
                }
            );

            }

        return collection[collection.size() - 1];

}

_______________________________________________________________________________________________________________________

0) RAII Это идеома возникшая с появлением языка C++, которая говорит о следующем
В момент обявление объекта, он получает в конструкторе доступ к какому то песурсу. Это могут быть поля, выделенная область памяти через new, открытия файла, Базы данных или установление соеденение по сети.
Далее после окончания работы с ресурсом и его сохранением, в момент вызова деструктора ресурс должен быть должным оброзом освободиться.

1) Шаблонный класс может быть использован для сохронение полученный данных в указатель в поле класса который по аналоги умного указателя nique_ptr.
Такое предположение у меня вазникло защет таго, что интерфейс класс указывает на это, а именно:
В классе явно запрещены конструктор копирования и присваения, по средствам
XXX(XXX const&) = delete;
XXX& operator=(XXX const&) = delete; что указывает на то что это как и у nique_ptr нельзя его копировать и присваевать тю.е. этот указатель унекальный
Также на это еще указывает метод get()  и release() - один возвращает сырой указатель на который указывает nique_ptr, второй отчищает его.

Назвать его можно было PTRUnique
*/

//  Реализация №1
/*
#include <iostream>
#include <iterator>
#include <vector>

using namespace std;

template <typename InputIt, typename OutputIt>
void scatter(InputIt first, InputIt last, OutputIt &d_first) {

    d_first.assign(first, last);

}

int main()
{

    vector<int> myVec{10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    vector<int> myVec1;

    scatter(myVec.begin(), myVec.end(), myVec1);

    for(int i =0; i < myVec1.size(); i++) {

        cout << myVec1[i] << endl;
    }


    cout << "Hello World!" << endl;

    return 0;
}
*/

// Реализация №2
#include <iostream>
#include <iterator>
#include <vector>

using namespace std;

template <typename InputIt, typename OutputIt>
OutputIt scatter(InputIt first, InputIt last, OutputIt result) {

    while (first != last) {

        *result++ = *first++;
    }

    return result;
}

int main()
{

    vector<int> myVec{10, 20, 30, 40, 50, 60, 70, 80, 90, 100};
    vector<int> myVec1;

    scatter(myVec.begin(), myVec.end(), back_inserter(myVec1));

    for(vector<int>::iterator it = myVec1.begin(); it != myVec1.end(); it++) {

        cout << *it << endl;
    }

    return 0;
}
